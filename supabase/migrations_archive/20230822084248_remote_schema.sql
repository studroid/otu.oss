create type "public"."node_type" as enum ('library', 'book', 'page');

alter table "public"."documents" drop constraint "documents_pkey";

drop index if exists "public"."documents_pkey";

drop table "public"."documents";

create table "public"."book" (
    "id" bigint generated by default as identity not null,
    "title" character varying default '100'::character varying,
    "body" text,
    "is_public" boolean default false,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null default auth.uid(),
    "embedding" vector
);


alter table "public"."book" enable row level security;

create table "public"."book_page_mapping" (
    "book_id" bigint not null,
    "page_id" integer not null,
    "is_public" boolean default true,
    "user_id" uuid not null default auth.uid(),
    "sort_position" integer,
    "seperator" text,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."book_page_mapping" enable row level security;

create table "public"."edge" (
    "parent_node_id" bigint not null,
    "child_node_id" bigint not null,
    "sort_position" smallint,
    "is_public" boolean default true,
    "user_id" uuid default auth.uid(),
    "separator" character varying,
    "updated_at" timestamp with time zone not null default now(),
    "created_at" timestamp with time zone not null default now()
);


create table "public"."library" (
    "id" bigint generated by default as identity not null,
    "title" character varying default '100'::character varying,
    "body" text,
    "is_public" boolean default false,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null default auth.uid(),
    "embedding" vector
);


alter table "public"."library" enable row level security;

create table "public"."library_book_mapping" (
    "library_id" bigint not null,
    "book_id" bigint not null,
    "is_public" boolean default true,
    "user_id" uuid not null default auth.uid(),
    "sort_position" integer,
    "separator" text,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."library_book_mapping" enable row level security;

create table "public"."node" (
    "id" bigint generated by default as identity not null,
    "title" character varying,
    "body" text,
    "embedding" vector,
    "is_public" boolean default false,
    "user_id" uuid default auth.uid(),
    "updated_at" timestamp with time zone not null default now(),
    "created_at" timestamp with time zone not null default now(),
    "type" node_type not null default 'page'::node_type
);


create table "public"."page" (
    "id" integer generated always as identity not null,
    "title" text not null,
    "body" text not null,
    "is_public" boolean default true,
    "user_id" uuid not null default auth.uid(),
    "embedding" vector,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."page" enable row level security;

create table "public"."profile" (
    "id" uuid not null,
    "nickname" character varying(15)
);


alter table "public"."topics" disable row level security;

drop sequence if exists "public"."documents_id_seq";

CREATE UNIQUE INDEX book_page_mapping_pk ON public.book_page_mapping USING btree (book_id, page_id);

CREATE UNIQUE INDEX book_pkey ON public.book USING btree (id);

CREATE UNIQUE INDEX edge_pkey ON public.edge USING btree (parent_node_id, child_node_id);

CREATE UNIQUE INDEX library_book_mapping_pk ON public.library_book_mapping USING btree (library_id, book_id);

CREATE UNIQUE INDEX library_pkey ON public.library USING btree (id);

CREATE UNIQUE INDEX node_pkey ON public.node USING btree (id);

CREATE UNIQUE INDEX pages_pk ON public.page USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profile USING btree (id);

alter table "public"."book" add constraint "book_pkey" PRIMARY KEY using index "book_pkey";

alter table "public"."book_page_mapping" add constraint "book_page_mapping_pk" PRIMARY KEY using index "book_page_mapping_pk";

alter table "public"."edge" add constraint "edge_pkey" PRIMARY KEY using index "edge_pkey";

alter table "public"."library" add constraint "library_pkey" PRIMARY KEY using index "library_pkey";

alter table "public"."library_book_mapping" add constraint "library_book_mapping_pk" PRIMARY KEY using index "library_book_mapping_pk";

alter table "public"."node" add constraint "node_pkey" PRIMARY KEY using index "node_pkey";

alter table "public"."page" add constraint "pages_pk" PRIMARY KEY using index "pages_pk";

alter table "public"."profile" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."book" add constraint "book_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."book" validate constraint "book_user_id_fkey";

alter table "public"."book_page_mapping" add constraint "book_page_mapping_book_id_fkey" FOREIGN KEY (book_id) REFERENCES book(id) ON DELETE CASCADE not valid;

alter table "public"."book_page_mapping" validate constraint "book_page_mapping_book_id_fkey";

alter table "public"."book_page_mapping" add constraint "book_page_mapping_page_id_fkey" FOREIGN KEY (page_id) REFERENCES page(id) ON DELETE CASCADE not valid;

alter table "public"."book_page_mapping" validate constraint "book_page_mapping_page_id_fkey";

alter table "public"."book_page_mapping" add constraint "book_page_mapping_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."book_page_mapping" validate constraint "book_page_mapping_user_id_fkey";

alter table "public"."edge" add constraint "edge_child_node_id_fkey" FOREIGN KEY (child_node_id) REFERENCES node(id) ON DELETE CASCADE not valid;

alter table "public"."edge" validate constraint "edge_child_node_id_fkey";

alter table "public"."edge" add constraint "edge_parent_node_id_fkey" FOREIGN KEY (parent_node_id) REFERENCES node(id) ON DELETE CASCADE not valid;

alter table "public"."edge" validate constraint "edge_parent_node_id_fkey";

alter table "public"."library" add constraint "library_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."library" validate constraint "library_user_id_fkey";

alter table "public"."library_book_mapping" add constraint "library_book_mapping_book_id_fkey" FOREIGN KEY (book_id) REFERENCES book(id) ON DELETE CASCADE not valid;

alter table "public"."library_book_mapping" validate constraint "library_book_mapping_book_id_fkey";

alter table "public"."library_book_mapping" add constraint "library_book_mapping_library_id_fkey" FOREIGN KEY (library_id) REFERENCES library(id) ON DELETE CASCADE not valid;

alter table "public"."library_book_mapping" validate constraint "library_book_mapping_library_id_fkey";

alter table "public"."library_book_mapping" add constraint "library_book_mapping_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."library_book_mapping" validate constraint "library_book_mapping_user_id_fkey";

alter table "public"."page" add constraint "page_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."page" validate constraint "page_user_id_fkey";

alter table "public"."profile" add constraint "profile_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profile" validate constraint "profile_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.attach_into_book_or_library(p_parent_id bigint, p_child_id integer, p_is_public boolean, p_parent_type text, p_position text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  target_position integer;
BEGIN
  IF p_parent_type = 'book' THEN
    IF p_position = 'prepend' THEN
      SELECT COALESCE(MIN(sort_position), 0) - 1 INTO target_position FROM book_page_mapping WHERE book_id = p_parent_id;
    ELSIF p_position = 'append' THEN
      SELECT COALESCE(MAX(sort_position), 0) + 1 INTO target_position FROM book_page_mapping WHERE book_id = p_parent_id;
    END IF;
    EXECUTE 'INSERT INTO book_page_mapping (book_id, page_id, sort_position, is_public) VALUES ($1, $2, $3, $4)' USING p_parent_id, p_child_id, target_position, p_is_public;
  ELSIF p_parent_type = 'library' THEN
    IF p_position = 'prepend' THEN
      SELECT COALESCE(MIN(sort_position), 0) - 1 INTO target_position FROM library_book_mapping WHERE book_id = p_parent_id;
    ELSIF p_position = 'append' THEN
      SELECT COALESCE(MAX(sort_position), 0) + 1 INTO target_position FROM library_book_mapping WHERE book_id = p_parent_id;
    END IF;
    EXECUTE 'INSERT INTO library_book_mapping (book_id, page_id, sort_position, is_public) VALUES ($1, $2, $3, $4)' USING p_parent_id, p_child_id, target_position, p_is_public;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_pages(query_embedding vector, match_threshold double precision, match_count integer, exclude_id integer)
 RETURNS TABLE(id bigint, title text, body text, similarity double precision)
 LANGUAGE sql
 STABLE
AS $function$
  select
    pages.id,
    pages.title,
    pages.body,
    1 - (pages.embedding <=> query_embedding) as similarity
  from pages
  -- where 1 - (pages.embedding <=> query_embedding) > match_threshold
  order by similarity desc
  limit match_count;
$function$
;

create policy "delete_owned_data_only"
on "public"."book"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "insert_authenticated_users_only"
on "public"."book"
as permissive
for insert
to authenticated
with check ((user_id = auth.uid()));


create policy "select_private_data"
on "public"."book"
as permissive
for select
to public
using (((is_public = false) AND (user_id = auth.uid())));


create policy "select_public_data"
on "public"."book"
as permissive
for select
to public
using ((is_public = true));


create policy "update_owned_data_only"
on "public"."book"
as permissive
for update
to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "delete_owned_data_only"
on "public"."book_page_mapping"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "insert_authenticated_users_only"
on "public"."book_page_mapping"
as permissive
for insert
to authenticated
with check ((user_id = auth.uid()));


create policy "select_private_data"
on "public"."book_page_mapping"
as permissive
for select
to public
using (((is_public = false) AND (user_id = auth.uid())));


create policy "select_public_data"
on "public"."book_page_mapping"
as permissive
for select
to public
using ((is_public = true));


create policy "update_owned_data_only"
on "public"."book_page_mapping"
as permissive
for update
to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "delete_owned_data_only"
on "public"."library"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "insert_authenticated_users_only"
on "public"."library"
as permissive
for insert
to authenticated
with check ((user_id = auth.uid()));


create policy "select_private_data"
on "public"."library"
as permissive
for select
to public
using (((is_public = false) AND (user_id = auth.uid())));


create policy "select_public_data"
on "public"."library"
as permissive
for select
to public
using ((is_public = true));


create policy "update_owned_data_only"
on "public"."library"
as permissive
for update
to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "delete_owned_data_only"
on "public"."library_book_mapping"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "insert_authenticated_users_only"
on "public"."library_book_mapping"
as permissive
for insert
to authenticated
with check ((user_id = auth.uid()));


create policy "select_private_data"
on "public"."library_book_mapping"
as permissive
for select
to public
using (((is_public = false) AND (user_id = auth.uid())));


create policy "select_public_data"
on "public"."library_book_mapping"
as permissive
for select
to public
using ((is_public = true));


create policy "update_owned_data_only"
on "public"."library_book_mapping"
as permissive
for update
to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "delete_owned_data_only"
on "public"."page"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "insert_authenticated_users_only"
on "public"."page"
as permissive
for insert
to authenticated
with check ((user_id = auth.uid()));


create policy "select_private_data"
on "public"."page"
as permissive
for select
to public
using (((is_public = false) AND (user_id = auth.uid())));


create policy "select_public_data"
on "public"."page"
as permissive
for select
to public
using ((is_public = true));


create policy "update_owned_data_only"
on "public"."page"
as permissive
for update
to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));



